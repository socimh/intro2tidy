{
  "hash": "aaab64fd300cefa9dbad1c44eb1cba67",
  "result": {
    "markdown": "---\ntheme: united\nlang: zh\ntoc: true\ntoc-depth: 3\ntoc-expand: 2\ntoc-title: 本页目录\nnumber-sections: true\n---\n\n\n\n# dplyr 统计\n\n-   类别变量\n    -   `count()` 计算各类别数量\n    -   `statart::tab()` 计算各类别数量、[**百分比、累计百分比**]{style=\"color:darkred\"}\n    -   `statart::tab1()` 同时列出[**多个**]{style=\"color:darkred\"}变量的上述统计量\n-   连续变量\n    -   `summarise()` 统计[**个别**]{style=\"color:darkred\"}统计量\n    -   `statart::summ()` 快速生成[**大量**]{style=\"color:darkred\"}变量的[**多个**]{style=\"color:darkred\"}统计量\n  \n\n## `count()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(tidyverse)\n\n# 显示每一类的数量\ndiamonds %>%\n  count(cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n  cut           n\n  <ord>     <int>\n1 Fair       1610\n2 Good       4906\n3 Very Good 12082\n4 Premium   13791\n5 Ideal     21551\n```\n:::\n:::\n\n\n\n## `tab()` 和 `tab1()`\n\n::: callout-caution\n## 注意\n\n这两个函数来自于我正在开发的 statart 包，暂时只能通过 `source()` 函数调用。\n:::\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# 在 count() 的基础上，多了很多信息\ndiamonds %>%\n  tab(cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 4\n  cut           n percent    cum\n  <chr>     <int>   <dbl>  <dbl>\n1 Fair       1610    2.98   2.98\n2 Good       4906    9.10  12.1 \n3 Very Good 12082   22.4   34.5 \n4 Premium   13791   25.6   60.0 \n5 Ideal     21551   40.0  100   \n6 total     53940  100     NA   \n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# 自动转换成列联表\ndiamonds %>%\n  tab(cut, clarity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 10\n  cut          I1   SI2   SI1   VS2   VS1  VVS2  VVS1    IF total\n  <chr>     <int> <int> <int> <int> <int> <int> <int> <int> <int>\n1 Fair        210   466   408   261   170    69    17     9  1610\n2 Good         96  1081  1560   978   648   286   186    71  4906\n3 Very Good    84  2100  3240  2591  1775  1235   789   268 12082\n4 Premium     205  2949  3575  3357  1989   870   616   230 13791\n5 Ideal       146  2598  4282  5071  3589  2606  2047  1212 21551\n6 total       741  9194 13065 12258  8171  5066  3655  1790 53940\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# 同时 tab1() 多个变量\ndiamonds %>%\n  tab1(cut:clarity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$cut\n# A tibble: 6 x 4\n  value         n percent    cum\n  <chr>     <int>   <dbl>  <dbl>\n1 Fair       1610    2.98   2.98\n2 Good       4906    9.10  12.1 \n3 Very Good 12082   22.4   34.5 \n4 Premium   13791   25.6   60.0 \n5 Ideal     21551   40.0  100   \n6 total     53940  100     NA   \n\n$color\n# A tibble: 8 x 4\n  value     n percent   cum\n  <chr> <int>   <dbl> <dbl>\n1 D      6775   12.6   12.6\n2 E      9797   18.2   30.7\n3 F      9542   17.7   48.4\n4 G     11292   20.9   69.3\n5 H      8304   15.4   84.7\n6 I      5422   10.1   94.8\n7 J      2808    5.21 100  \n8 total 53940  100     NA  \n\n$clarity\n# A tibble: 9 x 4\n  value     n percent    cum\n  <chr> <int>   <dbl>  <dbl>\n1 I1      741    1.37   1.37\n2 SI2    9194   17.0   18.4 \n3 SI1   13065   24.2   42.6 \n4 VS2   12258   22.7   65.4 \n5 VS1    8171   15.1   80.5 \n6 VVS2   5066    9.39  89.9 \n7 VVS1   3655    6.78  96.7 \n8 IF     1790    3.32 100   \n9 total 53940  100     NA   \n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# 同时 tab1() 多个变量，并返回成一个数据\ndiamonds %>%\n  tab1(cut:clarity, .append = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23 x 5\n   variable value         n percent    cum\n   <chr>    <chr>     <int>   <dbl>  <dbl>\n 1 cut      Fair       1610    2.98   2.98\n 2 cut      Good       4906    9.10  12.1 \n 3 cut      Very Good 12082   22.4   34.5 \n 4 cut      Premium   13791   25.6   60.0 \n 5 cut      Ideal     21551   40.0  100   \n 6 cut      total     53940  100     NA   \n 7 color    D          6775   12.6   12.6 \n 8 color    E          9797   18.2   30.7 \n 9 color    F          9542   17.7   48.4 \n10 color    G         11292   20.9   69.3 \n11 color    H          8304   15.4   84.7 \n12 color    I          5422   10.1   94.8 \n13 color    J          2808    5.21 100   \n14 color    total     53940  100     NA   \n15 clarity  I1          741    1.37   1.37\n16 clarity  SI2        9194   17.0   18.4 \n17 clarity  SI1       13065   24.2   42.6 \n18 clarity  VS2       12258   22.7   65.4 \n19 clarity  VS1        8171   15.1   80.5 \n20 clarity  VVS2       5066    9.39  89.9 \n21 clarity  VVS1       3655    6.78  96.7 \n22 clarity  IF         1790    3.32 100   \n23 clarity  total     53940  100     NA   \n```\n:::\n:::\n\n\n\n\n## `summarise()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# 平均钻石价格\ndiamonds %>%\n  summarise(mean(price))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 1\n  `mean(price)`\n          <dbl>\n1         3933.\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# 指定变量名\ndiamonds %>%\n  summarise(price = mean(price))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 1\n  price\n  <dbl>\n1 3933.\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n## `summ()`\n\n为了解决 `summarise()` 太原始的问题，我尽可能兼顾简便和实用，设计了一个新的函数 `summ()`。下面我来演示一些基础功能：\n\n::: callout-caution\n## 注意\n\n这个函数来自于我正在开发的 statart 包，暂时只能通过 `source()` 函数调用。\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# 统计 price 的变量类型、非缺失数、类别数、均值、标准差、最小值和最大值\ndiamonds %>%\n  summ(price)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 8\n  variable type      n unique  mean    sd   min   max\n  <chr>    <chr> <int>  <int> <dbl> <dbl> <int> <int>\n1 price    int   53940  11602 3933. 3989.   326 18823\n```\n:::\n:::\n\n\n\n解释一下上面的统计量：\n\n- `variable` 是变量名\n- `type` 是变量类型（如变量有单位，则为单位）\n- `n` 是该变量非缺失值的数量\n- `unique` 是变量的类别数（有多少个不重复的取值）\n  - 显然，`unique` $\\leq$ `n`\n  - `unique` 越大，意味着这个变量越“连续”，信息越丰富\n  - 比方说，**年龄**一般是0-120之间的某个正整数，而相应**月龄**的数量是年龄的12倍，**日龄**尤甚。所以在这三个变量里，**日龄**一般最平滑、最连续，信息量最大，相应的 `unique` 数也最大。\n- `mean` 是均值\n- `sd` 是标准差\n- `min` 是最小值\n- `max` 是最大值\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# 同时统计多个变量\ndiamonds %>%\n  summ(x:z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 8\n  variable type      n unique  mean    sd   min   max\n  <chr>    <chr> <int>  <int> <dbl> <dbl> <dbl> <dbl>\n1 x        dbl   53940    554  5.73 1.12      0  10.7\n2 y        dbl   53940    552  5.73 1.14      0  58.9\n3 z        dbl   53940    375  3.54 0.706     0  31.8\n```\n:::\n:::\n\n\n\n在 x, y, z 这三个维度上，钻石的 z（高度）最小，而 x 和 y 的均值几乎一样。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 展示所有统计量\ndiamonds %>%\n  summ(x:z, .detail = TRUE) %>%\n  print(width = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 18\n  variable type      n unique miss_n valid_pct   min    q1 median  mean   mad\n  <chr>    <chr> <int>  <int>  <int>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n1 x        dbl   53940    554      0         1     0  4.71   5.7   5.73 1.38 \n2 y        dbl   53940    552      0         1     0  4.72   5.71  5.73 1.36 \n3 z        dbl   53940    375      0         1     0  2.91   3.53  3.54 0.845\n     sd    q3   max   iqr  skew kurtosis      se\n  <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>   <dbl>\n1 1.12   6.54  10.7  1.83 0.379   -0.618 0.00483\n2 1.14   6.54  58.9  1.82 2.43    91.2   0.00492\n3 0.706  4.04  31.8  1.13 1.52    47.1   0.00304\n```\n:::\n:::\n\n\n\n可以看到，其实 x 和 y 在四分位数（q1 和 q3）上没有什么差别，但是它们的最大值（max）、偏度（skew）和峰度（kurtosis）上相差很多。我猜想，对于一些不规则的钻石，可能会把短边选为 x，而长边选为 y。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 自己选择一些统计量\ndiamonds %>%\n  summ(x:z, .stat = c(\"valid_pct\", \"mean\", \"se\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 5\n  variable type  valid_pct  mean      se\n  <chr>    <chr>     <dbl> <dbl>   <dbl>\n1 x        dbl           1  5.73 0.00483\n2 y        dbl           1  5.73 0.00492\n3 z        dbl           1  3.54 0.00304\n```\n:::\n:::\n\n\n\nvalid_pct 表示非缺失值的比例，这里为1，说明完全无缺失。se 是标准误，也就是对均值的误差估计。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 一次性选择所有变量\ndiamonds %>%\n  summ(everything())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in summ(., everything()): \n      cut, color, clarity are factor variables.\n      They are summarised (***), but the statistics may be misleading.\n      Consider using `tab1()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 8\n   variable   type      n unique     mean       sd   min      max\n   <chr>      <chr> <int>  <int>    <dbl>    <dbl> <dbl>    <dbl>\n 1 carat      dbl   53940    273    0.798    0.474   0.2     5.01\n 2 cut***     ord   53940      5    3.90     1.12    1       5   \n 3 color***   ord   53940      7    3.59     1.70    1       7   \n 4 clarity*** ord   53940      8    4.05     1.65    1       8   \n 5 depth      dbl   53940    184   61.7      1.43   43      79   \n 6 table      dbl   53940    127   57.5      2.23   43      95   \n 7 price      int   53940  11602 3933.    3989.    326   18823   \n 8 x          dbl   53940    554    5.73     1.12    0      10.7 \n 9 y          dbl   53940    552    5.73     1.14    0      58.9 \n10 z          dbl   53940    375    3.54     0.706   0      31.8 \n```\n:::\n:::\n\n\n\n请注意，因为 cut, color, clarity 都是定序变量，所以 `summ()` 它们比较牵强。对它们使用前文的 `tab1()` 会更为合适。\n\n<!-- 下面我想用一个更复杂的数据来体现 `summ()` 的强大之处。 -->\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,000\nColumns: 14\n$ date      <date> 2024-02-08, 2024-02-07, 2024-02-06, 2024-02-05, 2024-02-04,~\n$ time      <dttm> 2024-02-09 11:59:59, 2024-02-09 11:59:58, 2024-02-09 11:59:~\n$ duration1 <drtn> 3 hours, 4 hours, 5 hours, 6 hours, 7 hours, 8 hours, 9 hou~\n$ duration2 <time> 12:34:56, 12:34:56, 12:34:56, 12:34:56, 12:34:56, 12:34:56,~\n$ string    <chr> \"ABC\", \"ABC\", \"ABC\", \"ABC\", \"ABC\", \"ABC\", \"ABC\", \"ABC\", \"ABC~\n$ logical   <lgl> TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FA~\n$ unit1     [m] 1 [m], 2 [m], 3 [m], 4 [m], 5 [m], 6 [m], 7 [m], 8 [m], 9 [m],~\n$ unit2     [m^2] 1 [m^2], 2 [m^2], 3 [m^2], 4 [m^2], 5 [m^2], 6 [m^2], 7 [m^2~\n$ factor    <fct> a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, ~\n$ order     <ord> a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, ~\n$ double    <dbl> 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, ~\n$ integer   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1~\n$ half_miss <dbl> 1, NA, 3, NA, 5, NA, 7, NA, 9, NA, 11, NA, 13, NA, 15, NA, 1~\n$ all_miss  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ~\n```\n:::\n:::\n\n\n\n<!-- 通过 `glimpse()` 可以看到，这个数据非常复杂，几乎囊括了常见的各种数据类型。让我们来 `summ()` 一下这个数据： -->\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplex_tb %>%\n  codebook()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in un[i] <- at$units: number of items to replace is not a multiple of\nreplacement length\n\nWarning in un[i] <- at$units: number of items to replace is not a multiple of\nreplacement length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 14 x 4\n   variable  type                 n unique\n   <chr>     <chr>            <int>  <int>\n 1 date      date              1000   1000\n 2 time      datetime          1000   1000\n 3 duration1 duration [hours]  1000   1000\n 4 duration2 time [secs]       1000      1\n 5 string    character         1000      1\n 6 logical   logical           1000      2\n 7 unit1     units [m]         1000   1000\n 8 unit2     units [m^2]       1000   1000\n 9 factor    factor            1000      2\n10 order     ordered           1000      2\n11 double    double            1000   1000\n12 integer   integer           1000   1000\n13 half_miss double             500    500\n14 all_miss  double               0      0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplex_tb %>%\n  summ(everything())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in summ(., everything()): \n    string is non-numeric.\n    Use `tab()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in summ(., everything()): \n      date, time are date or datetime variables.\n      Use `summ_date()` or `summ_all()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in summ(., everything()): \n      factor, order are factor variables.\n      They are summarised (***), but the statistics may be misleading.\n      Consider using `tab1()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in summ(., everything()): \n    all_miss is entirely missing and thus removed.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 8\n   variable  type        n unique    mean      sd     min   max\n   <chr>     <chr>   <int>  <int>   <dbl>   <dbl>   <dbl> <dbl>\n 1 duration1 [hours]  1000   1000   502.  289.        3    1002\n 2 duration2 [secs]   1000      1 45296     0     45296   45296\n 3 logical   lgl      1000      2     0.5   0.500     0       1\n 4 unit1     [m]      1000   1000   500.  289.        1    1000\n 5 unit2     [m^2]    1000   1000   500.  289.        1    1000\n 6 factor*** fct      1000      2     1.5   0.500     1       2\n 7 order***  ord      1000      2     1.5   0.500     1       2\n 8 double    dbl      1000   1000    50.0  28.9       0.1   100\n 9 integer   int      1000   1000   500.  289.        1    1000\n10 half_miss dbl       500    500   500   289.        1     999\n```\n:::\n:::\n\n\n\n<!-- 小结一下，可以划分出三大类变量，分别是\n\n- `summ()` 无法统计\n  - 无法转换成数值的变量，如 string（建议使用`tab1()`）\n  - 日期时间类变量，如 date 和 datetime（建议使用`summ_date()`）\n  - 全部缺失的变量，如 all_miss\n- `summ()` 可以统计，但结果通常无意义\n  - 类别型变量，如 factor 和 order（建议使用`tab1()`）\n- `summ()` 可以统计，且结果有意义\n  - 数值型变量，如 double 和 integer\n  - 含单位的数值变量，如 unit1 和 unit2\n  - 时间区间变量，如 duration1 和 duration2\n  - 逻辑型变量（虚拟变量），如 logical -->\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "dplyr-stat_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}